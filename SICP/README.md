# SCIP note

-----

- [第一章 构造抽象过程](#1)
  - [程序设计的基本元素](#1.1)
  - [过程与它们所产生的计算](#1.2)
  - [用高阶函数做抽象](#1.3)
- [第二章](#2)
  - [](#2.1)
  - [](#2.2)
  - [](#2.3)
  - [](#2.4)
  - [](#2.5)
- [第三章](#3)
  - []()
- [第四章](#4)
  - [](#4.1)
- [第五章](#5)
  - [](#5.1)



&nbsp;   
<a id="1"></a>
# 第一章 构造抽象过程

&nbsp;   
<a id="1.1"></a>
## 1.1 程序设计的基本元素

- **表达式**：前缀形式
- **组合**：
- **抽象**：命名，使用名称去引用一个运算结果。（这意味着 interpreter 必须维护某种存储能力，被称为 **环境**）

过程定义：  
`(define (<name> <formal parameters>) <body>)`  

代换模型：将过程调用替换为函数体。   

**应用序** 和 **正则序**：

- 应用序：先求值参数而后应用。
- 正则序：完全展开之后规约。

>Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟的过程范围后，正则序的处理将变得复杂得多。

&nbsp;   

**条件表达式** 和 **谓词**：

    (cond (<p1> <e1>)
          (<p2> <e2>)
          ..
          (<pn> <en>))
**条件表达式的求值方式**如下：   
首先求值谓词`<p1>`，如果它的值是`false`，那么继续向下求值，知道发现了某个谓词的值为`true`，返回相应的序列表达式`<e>`的值，以这个值作为条件表达式的值。如果没有，则没有定义。

>注：`<e>`可以是一个表达式的序列，如果对应的`<p>`为真，那么`<e>`会被顺序求值，并将最后一个表达式的值作为返回值。

&nbsp;   

特殊形式：`if`   
`if <predicate> <consequent> <alternative>`   
**在求值一个`if`表达式时**，解释器从求值其`<predicate>`部分开始，如果`<predicate>`得到真值，解释器就去求值`<consequent>`并返回其值，否则就去求值`<alternative>`并返回其值。
   

>注：`if` 是一种特殊的形式，`<consequent>`和`<alternative>`只有一个被求值。   
>而在练习1.6提出的问题中，`new-if`被定义如下：   
>(define (new-if predicate then-clause else-clause)  
&emsp;&emsp;(cond (predicate then-clause)  
&emsp;&emsp;&emsp;&emsp;&emsp;(else else-clause)))   
>`new-if`会对两个子表达式都进行求值。

&nbsp;   

其他复合运算：   
`(and <e1> ... <en>)`   
`(or <e1> ... <en>)`   
`(not <e>)`

注意`and`和`or`都是特殊形式而不是普通的过程，因为它们的子表达式不一定都求值。而`not`则是一个普通的过程。

&nbsp;   

**黑箱抽象**：



&nbsp;   
<a id="1.2"></a>
## 1.2 过程与它们所产生的计算




&nbsp;   
<a id="1.3"></a>
## 1.3 用高阶函数做抽象




&nbsp;   
<a id="2"></a>




&nbsp;   
<a id="2.1"></a>




&nbsp;   
<a id="2.2"></a>




&nbsp;   
<a id="2.3"></a>



&nbsp;   
<a id="2.4"></a>



&nbsp;   
<a id="2.5"></a>



&nbsp;   
<a id="3"></a>
