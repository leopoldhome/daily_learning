# SICP note

[视频教程](https://github.com/DeathKing/Learning-SICP)   
[SICP book online](https://sarabander.github.io/sicp/html/index.xhtml)   

其他笔记：

- [Keep Writing Codes - Lisp 追随者，SICP 受益者，持续分享编程心得](https://liujiacai.net/tags/sicp/)
- [鉴心 - blog](http://coderyang.com/tags/sicp/)

其他题解：

- [Articles in tag "SICP"](https://eli.thegreenplace.net/tag/sicp)
- [SICP 解题集](https://sicp.readthedocs.io/en/latest/)

&nbsp;   

-----

- [第一章 构造抽象过程](#1)
  - [程序设计的基本元素](#1.1)
  - [过程与它们所产生的计算](#1.2)
  - [用高阶函数做抽象](#1.3)
- [第二章 构造数据抽象](#2)
  - [数据抽象导引](#2.1)
  - [层次性数据和闭包性质](#2.2)
  - [符号数据](#2.3)
  - [抽象数据的多重表示](#2.4)
  - [带有通用型操作的系统](#2.5)
- [第三章 模块化、对象和状态](#3)
  - [赋值和局部状态](#3.1)
  - [求值的环境模型](#3.2)
  - [用变动数据做模拟](#3.3)
  - [并发：时间是一个本质问题](#3.4)
  - [流](#3.5)
- [第四章 元语言抽象](#4)
  - [](#4.1)
  - [](#4.2)
  - [](#4.3)
  - [](#4.4)
- [第五章 寄存器机器里的计算](#5)
  - [](#5.1)
  - [](#5.2)
  - [](#5.3)
  - [](#5.4)
  - [](#5.5)

TODO:

- [Church 计数 - ex 2.6](#church)

&nbsp;   
&nbsp;   
<a id="1"></a>
# 第一章 构造抽象过程

&nbsp;   
<a id="1.1"></a>
## 1.1 程序设计的基本元素

- **表达式**：前缀形式
- **组合**：
- **抽象**：命名，使用名称去引用一个运算结果。（这意味着 interpreter 必须维护某种存储能力，被称为 **环境**）

过程定义：  
`(define (<name> <formal parameters>) <body>)`  

代换模型：将过程调用替换为函数体。   

**应用序** 和 **正则序**：

- 应用序：先求值参数而后应用。
- 正则序：完全展开之后规约。

>Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟的过程范围后，正则序的处理将变得复杂得多。

&nbsp;   

**条件表达式** 和 **谓词**：

    (cond (<p1> <e1>)
          (<p2> <e2>)
          ..
          (<pn> <en>))
**条件表达式的求值方式**如下：   
首先求值谓词`<p1>`，如果它的值是`false`，那么继续向下求值，知道发现了某个谓词的值为`true`，返回相应的序列表达式`<e>`的值，以这个值作为条件表达式的值。如果没有，则没有定义。最后可以出现 `else` ，行为如同 default.  

>注：`<e>`可以是一个表达式的序列，如果对应的`<p>`为真，那么`<e>`会被顺序求值，并将最后一个表达式的值作为返回值。

&nbsp;   

特殊形式：`if`   
`if <predicate> <consequent> <alternative>`   
**在求值一个`if`表达式时**，解释器从求值其`<predicate>`部分开始，如果`<predicate>`得到真值，解释器就去求值`<consequent>`并返回其值，否则就去求值`<alternative>`并返回其值。
   

>注：`if` 是一种特殊的形式，`<consequent>`和`<alternative>`只有一个被求值。   
>而在练习1.6提出的问题中，`new-if`被定义如下：   
>(define (new-if predicate then-clause else-clause)  
&emsp;&emsp;(cond (predicate then-clause)  
&emsp;&emsp;&emsp;&emsp;&emsp;(else else-clause)))   
>`new-if`会对两个子表达式都进行求值。

&nbsp;   

其他复合运算：   
`(and <e1> ... <en>)`   
`(or <e1> ... <en>)`   
`(not <e>)`

注意`and`和`or`都是特殊形式而不是普通的过程，因为它们的子表达式不一定都求值。而`not`则是一个普通的过程。

&nbsp;   

**黑箱抽象**：

- **过程抽象**：只关心功能与接口格式。分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以用作定义其他过程的模块。
- **形参局部名**：过程的形式参数应该是相应过程体里的局部名字。
- **内部定义** 和 **块结构**：核心过程中依赖的其他过程应该被内部化，否则会污染其他库实现。（即这些辅助函数不够全局）

如果在一个完整的过程里面**约束变量**全部换名，那么过程的意义将没有任何改变。   
如果一个变量是不被约束的，我们称它为**自由**的。  
**作用域**：被声明为过程的形参的约束变量，就以这个过程的体(`body`)作为它们的作用域。

内部定义与块结构：  

    #lang sicp
    (define (square x) (* x x) )
    (define (average x y) (/ (+ x y) 2))
    
    (define  (sqrt x)
      (define (good-enough? guess x)
          (< (abs (- (square guess) x)) 0.001)
      )
      (define (improve guess x)
          (average guess (/ x guess))
      )
      (define (sqrt-iter guess x)
          (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x))
      )
     (sqrt-iter 1.0 x)
    )


使用块结构的好处：

- 将辅助过程定义到内部
- 不用显式的传递某些参数，可以让这些参数作为内部定义中的自由变量（词法作用域）



&nbsp;   
<a id="1.2"></a>
## 1.2 过程与它们所产生的计算

- 递归计算过程：计算过程构造一个 **推迟进行的操作** 所形成的链条，收缩阶段表现为这些运算的实际执行。（解释器需要维护好那些以后将要执行的操作的轨迹）
- 迭代计算过程：那种其状态可以用固定数目的状态变量描述的计算过程；而与此同时，又存在着一套固定的规则，描述了计算过程在从一个状态到达下一个状态转换时，这些变量的更新方式；还有一个（可能有的）结束检测，它描述这一计算过程应该终止的条件。

对于**树形递归**，计算中的每一点，我们都只需保存树中在此之上的结点的轨迹。一般来说，树形递归的计算过程所需的步骤将正比于树中的结点树，其空间需求正比于树的最大深度。





&nbsp;   
<a id="1.3"></a>
## 1.3 用高阶函数做抽象

强大语言的需求：为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。

**高阶过程**：这样的过程，让他们以过程为参数，或者以过程为返回值。

使用 **lambda** 构造匿名过程：   
`(lambda (<formal-parameters>) <body>)`
定义过程的另一种写法：  

    (define foo
        (lambda (x) 
          return-expr))

用 **let** 创建局部变量：  

    (let ((<var1><expr1>)
          (<var2><expr2>)
          ...
          (<varn><exprn>))
     <body>)

当 let 被求值时，这里的每个名字将被关联到对应表达式的值。在将这些名字约束为局部变量的情况下求值 let 体。可以认为 let 表达式描述的变量的作用域就是该 let 的体。  

- let 使人能在尽可能接近其使用的地方建立局部变量约束。
- 变量的值是在 let 之外计算的。

**抽象**和**第一级过程**：高阶过程的重要性，就在于使我们能显式地使用程序设计语言的要素去描述这些抽象，使我们能够像操作其他计算元素一样去操作它们。   

一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有最少限制的元素被称为具有*第一级*的状态。第一级元素的某些“权利或者特权”包括：

- 可以用变量命名
- 可以提供给过程做参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

Lisp 给了过程完全的第一级状态，由此获得的描述能力是及其惊人的。

>实现第一级过程的主要代价是：为使过程能够作为值返回，我们就需要为过程里的自由变量保存空间，即使这一过程并不执行。



&nbsp;   
&nbsp;   
<a id="2"></a>
# 第二章 构造数据抽象


将对象数据复合起来，形成*复合数据*的方式。([AOS & SOA](https://en.wikipedia.org/wiki/AOS_and_SOA))   
**数据抽象**：将 *数据对象的表示* 与 *处理数据对象的过程* 分开。

数据抽象的意义：

- 降低程序间的耦合度
- 提高设计的模块性
- 增强语言表达能力，为处理计算问题提供更多手段和方法

本章内容：

- 数据抽象
- 闭包
- 符号表达式
- 通用型操作符
- 数据导向的程序设计

&nbsp;   
<a id="2.1"></a>
## 2.1 数据抽象导引

数据抽象的基本思想：

- 就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样，它们不对所用数据做任何多余的假设。
- 为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述。

**序对**：

    (car (cons a b)) -> a
    (cdr (cons a b)) -> b

可能的实现：（由 `cons` 返回的值是一个过程）

    (define (cons a b)
        (lambda (pick)
             (cond ((= pick 1) a)
                   ((= pick 2) b))))
                   
    (define (car x) (x 1))
    (define (cdr x) (x 2))

因此，序对的这一过程实现确实是一个合法的实现，如果只通过 `cons`、 `car` 和 `cdr` 访问序对，我们将无法把这一实现与“真正的”数据结构分开。   
上面展示了序对的一种过程性表示，这并不意味着我们所用的语言就是这样做的（Scheme 和一般的 Lisp 系统都直接实现序对，主要是为了效率），而是说它确实可以这样做。   
**数据的过程性表示将在我们的程序设计宝库里扮演一种核心角色。有关的程序设计风格通常被称为消息传递。**

练习 2.4 另一种序对的实现：

    (define (cons x y)
      (lambda (m) (m x y)))
    
    (define (car c)
      (c (lambda (p q) p)))
      
    (define (cdr c)
      (c (lambda (p q) q)))

<a id="church"></a>
练习 2.6 Church计数：




&nbsp;   
<a id="2.2"></a>
## 2.2 层次性数据和闭包性质

一般说，某种组合数据对象的操作满足**闭包性质**，那就是说，通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。   
所有程序都依赖于一个事实：组合式的成员本身还可以是组合式。    

强健设计的语言层次：

- 分层设计：构造各个层次的方式，就是设法组合起作为这一层次中部件的各种基本元素，这样构造出的部件又可以作为另一个层次里的基本元素。
- 每个层次都提供了一些**基本元素**、**组合手段**和**对该层次中的适当细节做抽象的手段**。
- 分层设计有助于使程序更加健壮，使我们更有可能在给定规范发生一些小改变时，只需对程序做少量的修改。


&nbsp;   
<a id="2.3"></a>
## 2.3 符号数据

为了扩充语言的表述能力，引进任意符号作为数据的功能。需要有一种新元素：为数据对象加**引号**的能力。



&nbsp;   
<a id="2.4"></a>
## 2.4 抽象数据的多重表示

**数据抽象屏障**是控制复杂性的强有力工具。通过对数据对象基础表示的屏蔽，我们就可以将设计一个大程序的任务，分割为一组可以分别处理的较小任务。   
对于一个数据对象也可能存在*多种有用的表示方式*，而且我们也可能希望所设计的系统能够处理*多种表示方式*。因此需要抽象屏障去隔离互不相同的设计选择，以便允许不同的设计选择在同一个程序里共存。   

- **通用型过程**：在不止一种数据表示上操作的过程。（这里的主要技术是：在带有 **类型标志** 的数据对象上工作）
- **类型标志**：数据对象包含着它们应该如何处理的明确信息。([Ad-hoc overloading Polymorphism](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism) & [Parametric Polymorphism](https://en.wikipedia.org/wiki/Parametric_polymorphism))
- **数据导向的程序设计**：

&nbsp;   
### 带标志数据：   
认识数据抽象的一种方式是将其看作 “最小允诺原则” 的一个应用。   
抽象屏障使我们可以把为自己所用数据对象选择具体表示形式的事情尽量向后推，而且还能保持系统设计的最大灵活性。   
*那么就需要有一种方式，将不同的数据表示分开。*   
完成这种区分的一种方式， 就是在数据对象里包含一个 **类型标志** 部分。   

每个通用选择过程都需要实现为这样的过程，它首先检查参数的标志，而后去调用处理该类数据的适当过程。   
因为每个数据对象都以其类型作为标志，选择函数就能够在不同的数据上以一种通用的方式操作。也就是说，每个选择函数的定义行为依赖于它操作其上的特定的数据类型。   
在将数据对象从一个层次传到另一个层次的过程中，这种剥去和加上标签的规范方式成为一种重要的组织策略。（[Type erasure](https://en.wikipedia.org/wiki/Type_erasure)）

&nbsp;   
### 数据导向的程序设计和可加性：   
检查一个数据项的类型，并据此去调用某个适当过程称为 **基于类型的分派**。在系统设计中，这是一种强有力的策略。   
而另一方面，通过 `if-else` 来判断类型并派发过程有另个显著地弱点：

- 其中的这些通用型界面过程必须知道所有的不同表示。
- 即使这些独立的表示形式可以分别设计，我们也必须保证在整个系统里不存在两个名字相同的过程。

这两个弱点带来的问题是：   
上面这种实现通用型界面的技术不具有 **可加性**。   
在每次增加一种新表示形式时，实现通用选择函数的人都必须修改他们的过程，而那些做独立表示的界面的人也必须修改其代码，以避免名字冲突问题。在做这些事情时，所有修改都必须直接对代码去做，而且必须准确无误。这当然会带来极大的不便，而且还很容易引进错误。   

**数据导向的程序设计**：能够将系统设计进一步模块化的方法。   
在需要处理的是针对不同类型的一集公共通用型操作时，事实上，我们正在处理一个二维表格，其中的一维上包含着所有的可能操作，另一个维上就是所有的可能类型。   
数据导向的程序设计就是一种使程序能直接利用这种表格工作的程序设计技术。   
实现这样一个过程，去做基于类型的显示分派：用操作名和参数类型的组合到表格中查找，以便找出应该调用的适当过程。   

&nbsp;   
### 消息传递：   
在数据导向的程序设计里，最关键的想法就是通过显式处理操作—类型表格的方式，管理程序中的各种通用操作。   
两种实现策略：

- 基于类型的分派，其中让每个操作管理自己的分派。
- 将表格按列进行分解，采用 “智能数据对象”，让它们**基于操作名完成所需的分派工作**。（做法：将每一个数据对象表示为一个过程。它以操作的名字作为输入，能够去执行指定的操作。）

采用“智能数据对象”的程序设计风格称为：**消息传递**。   
这一名字源自将数据对象设想为一个实体，它以 “消息” 的方式接收到所需操作的名字。


&nbsp;   
<a id="2.5"></a>
## 2.5 带有通用型操作的系统

在一个大型的复杂系统里可能有许多层次，每层与下一层次之间的连接都借助于一些通用型操作。当一个数据对象被“向下”传输时，用于引导它进入适当程序模块的最外层标志被剥除，下一层的标志变为可见的，并将用于下一次分派。
![](assets/2_24.png)

### 不同类型数据的组合：   
这牵扯到一个问题：由谁来负责这些过程。在设计包含许多程序模块和许多跨类型操作的系统时，要想规划好一套统一的策略，分清各种模块之间的责任，很容易变成一个非常复杂的任务。   

**强制**（**coercion**）：（可以利用潜藏在类型系统之中的一些额外结构）   
不同的数据类型通常都不是完全相互无关的，常常存在一些方式，使我们可以把一种类型的对象看作另一种类型的对象。   
实现手段：   
1. 设计出一些强制过程，它们能把一个类型的对象转换到另一类型的等价对象。   
2. 将这些强制过程安装到一个特殊的强制表格中，用两个类型的名字作为索引。   
3. 应用一个操作时，首先检查是否存在针对实际参数类型的操作定义，就像前面一样。如果存在，那么就将任务分派到由 “操作—类型” 表格中找出相应的过程，否则就去做强制。   

与显式定义的跨类型操作相比，这种强制模式有许多优越性：虽然仍要写出与类型有关的强制过程，但是只需要为每一对类型写一个过程，而不是为每对类型和每个通用型操作写一个过程。能够这样做的基础就是：类型之间的适当转换至依赖于类型本身，而不依赖于所实际应用的操作。

### 类型的层次结构

在实际中，还存在着不同类型相互关系更全局性的结构。   
![塔结构](assets/2_25.png)   
称为：塔结构   
此后，当系统遇到需要对两个不同类型的运算时，它就可以逐步提升较低的类型，直至所有对象都达到了塔的同一个层次。   
于是很自然地引入一个概念：**继承**

### 层次结构的不足
如果在一个系统里，有关的数据类型可以被自然地安排为一个塔型，那么处理不同类型上通用型操作的问题将能得到极大的简化。遗憾的是，事情通常不是这样。   
一个类型有可能有东哥子类型，也有可能有多个超类型，这就意味着：   
**并不存在一种唯一的方式在层次结构中去 “提升” 一个类型。**   
![](assets/2_26.png)   
当需要将一个操作应用于一个对象时，为此找出“正确”超类型的工作可能涉及到对整个类型网络的大范围搜索。   
**在设计大型系统时，处理好一大批有关的类型而同时又能保持模块性，这是一个非常困难的问题。**   
>注：今天已经有了一批各式各样的并不合适的本体理论，它们已经被嵌入到数量过多而又先天不足的各种程序设计语言里。**面向对象语言的核心是对类型之间通用型操作的处理**。但“类”与“继承”并非最佳实践。事实上，目前的猜想是：如果没有知识表述和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式合理处理的。

一种类型的对象事实上可以是一个复杂的对象，又以许多不同类型的对象作为其组成部分。这种情况并不会给通用型操作增加任何实际困难。需要做的就是针对这种复合对象的各个部分的操作，并安装好适当的通用型过程。

在设计大型系统时，大部分复杂性都牵扯到多个类型之间的关系。确实，人们到现在都还没有完全理解强制。事实上，人们还没有完全理解类型的概念。但无论如何，已知的东西已经为我们提供了支持大型系统设计的强有力的结构化和模块化原理。



&nbsp;   
&nbsp;   
<a id="3"></a>
# 第三章 模块化、对象和状态

基于被模拟系统的结构去设计程序的结构：对于有关的物理系统里的每个对象，我们构造一个与之对应的计算对象；对该系统里的每种活动，我们在自己的计算系统里定义一种符号操作。   
两种策略：

- **对象**：将一个系统看成一大批对象，它们的行为可能随着时间的进展而不断变化。
- **信息流**

在处理对象、变化和标识时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗。如果允许程序**并发**执行的可能性，事情就会变得困难的许多。**流方式** 特别能够用于松解在我们的模型中对时间的模拟与计算机求值过程中的各种事件发生的顺序。这种技术称为 “**延时求值**”。


&nbsp;   
<a id="3.1"></a>
## 3.1 赋值和局部状态

每个对象都有自己的随时间变化的状态。   
**状态变量**：用来刻画一个对象的状态，在它们之中维持着对象的充分信息。   
每个对象都可能通过交互作用，影响其他对象的状态。   

模块化 →    
分解为一批计算对象，用来模拟 →    
对象有局部状态变量，用于描述对象的状态 →    
由于被模拟系统里的对象的状态是随时间变化的，与它们相对应的计算对象的状态也必须变化 →    
如果要通过计算机中的时间流逝去模拟实际的时间流逝，那么计算对象的行为必须是可以随着程序运行而改变的 →    
如果希望用程序设计语言中的符号名字去模拟状态变量 →    
语言必须提供一个赋值运算符

`(SET! <var> <value>)`


&nbsp;   
<a id="3.2"></a>
## 3.2 求值的环境模型




&nbsp;   
<a id="3.3"></a>
## 3.3 用变动数据做模拟



&nbsp;   
<a id="3.4"></a>
## 3.4 并发：时间是一个本质问题




&nbsp;   
<a id="3.5"></a>
## 3.5 流





&nbsp;   
&nbsp;   
<a id="4"></a>


&nbsp;   
<a id="4.1"></a>



&nbsp;   
<a id="4.2"></a>


&nbsp;   
<a id="4.3"></a>


&nbsp;   
<a id="4.4"></a>




&nbsp;   
&nbsp;   
<a id="5"></a>




&nbsp;   
<a id="5.1"></a>


&nbsp;   
<a id="5.2"></a>


&nbsp;   
<a id="5.3"></a>


&nbsp;   
<a id="5.4"></a>


